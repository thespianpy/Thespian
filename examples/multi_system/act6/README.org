* Thespian Multi-System Configurations, Act 6

This Act will resolve the code update issue described in [[file:../act5][Act 5]]:
updating running Actor code requires a full restart of the Actor
System (or *all* Actor Systems).

This will be done using the loadable source feature of Thespian.  This
feature allows a zip file containing the updated sources to be loaded
into a running Actor System.  Each load returns a hash value
identifying that set of loaded sources; this hash value may be passed
to the ~createActor()~ call to request that the actor be instantiated
from the associated loaded sources.

In order to support the dynamic loading of sources, a special Actor
must register itself as the Source Authority.  Any load of a new
source file will cause that source file to be passed to the Source
Authority.  The Source Authority can perform any desired validation
and/or decryption of the source, and then pass back the validated
version to Thespian.  Only when the validated version is passed back
to Thespian will Thespian allow the creation of Actors from that
source.

For the purposes of this example, a very simple Source Authority Actor
will be loaded that will automatically validate all sources.  In a
normal environment, the Source Authority will be much more selective,
validating the new source against a digital signature or performing
some other type of validation to maintain executable security.

The Source Authority Actor is automatically loaded by the ~start.py~
in this example.

Loadable sources can be created by running the ~makeload.sh~ shell
script, and the resulting ~src.zip~ file can be loaded via the
~load.py~ script, specifying the port number of the system to load the
sources into:

#+BEGIN_EXAMPLE
$ edit ....
$ bash makeload.sh
$ ls -lh src.zip
$ python load.py 1900
a3ad084f02e92c6a2e3eb70e5d72a6c2
$ echo hello | python app.py a3ad084f02e92c6a2e3eb70e5d72a6c2
#+END_EXAMPLE

The ~app.py~ is updated to take the sourceHash of the loaded sources
that it is supposed to use for creating the Actor.  Note that the
~globalName~ argument has also been updated: the globalName is checked
first, so any subsequent ~createActor()~ call using the same
globalName would simply get the previously loaded version and the
target sourceHash would be ignored.

** Multiple Loaded Sources

The above can be repeated multiple times.  Each time an new source
hash is generated.  Of particular interest is that previous source
hash values may be used on the ~app.py~ invocation and they will
continue to work and generate the results that correspond to their
source.  This is because the previously loaded sources continue to
exist and can be used side-by-side with newly loaded versions.

Reloading a previously loaded source does nothing, and does not
interfere with the currently loaded source or any Actors that were
started from it.

This ability to have multiple versions of sources loaded
simultaneously is a powerful tool for dynamically updating a running
environment:

   1. New sources can be loaded without service interruption.
   2. The old version continues to run and "drain" requests that it
      was actively processing, whereas new requests can be directed to
      the new version.
   3. See below...

** Automatic Remote Source Distribution

In the above example, the load operation was *only* performed on the
Actor System running at port 1900, yet the newly loaded sources could
be instantiated in any of the Actor Systems.

It is also possible to experiment with the ~chgcap.py~ utility to
modify the capabilities of running systems and observe the automatic
re-creation of Actors in systems where it is viable for them to run.

This is a demonstration of the third advantage of loaded sources that
was alluded to above: loaded sources are automatically propagated to
"remote" Actor Systems as they are needed.  This allows centralized
management and updating of new Actor application distributions.  When
a remote system is requested to create an Actor from a loaded source
that it does not have, it will automatically request that loaded
source from the Actor System that requested the Actor startup.

It is also key to note that the name of the loaded zipfile is not
significant: the sources are identified by hash values.  This allows
the zipfile name to contain metadata like version or date information
as generated by a CI/CD system.

** Unloading Sources

Naturally, continuing to accumulate sources in the running system will
consume otherwise unused resources.  The ~unload.py~ script
demonstrates the ability to unload sources on-demand:

#+BEGIN_EXAMPLE
$ python load.py 1900 a3ad084f02e92c6a2e3eb70e5d72a6c2
$ echo hello | python app.py a3ad084f02e92c6a2e3eb70e5d72a6c2
...exception...
thespian.actors.InvalidActorSourceHash: Source hash
   a3ad084f02e92c6a2e3eb70e5d72a6c2 does not match any
   loaded sources.
$
#+END_EXAMPLE

(The above exception output was line-wrapped for easier reading.)

** Conclusion

This concludes the presentation of the multi-system capabilities and
features of the Thespian Actor System.  A production-level Actor
application would typically build upon the techniques here to provide:

  * A Source Authority using strong digital signature verification to
    ensure only proper sources are loaded.

  * A small loadable source Actor set that probes the current
    environment and sets capabilities of the local Actor System.  This
    loadable source would register for notification of the presence of
    new remote Actor Systems (via
    ~self.notifyOnSystemRegistrationChanges()) and invoke itself on
    those remote systems.

  * A separate loadable source representing the Actor-based
    application that has Actors specifying their required capabilities
    when starting up.

  * A loadable source building and signing tool, coupled with a load
    and unload tool that is run on the primary Actor System host.

